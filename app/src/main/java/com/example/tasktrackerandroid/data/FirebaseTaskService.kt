package com.example.tasktrackerandroid.data

import android.util.Log
import com.example.tasktrackerandroid.data.model.Task
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.cancel
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch

/**
 * Firebase-based implementation of the TaskRepository interface.
 * @param db The Firebase Firestore instance.
 * @param auth The Firebase Authentication instance.
 * @param dataStore The TaskDataStore instance.
 */
class FirebaseTaskService @Inject constructor(
    private val db: FirebaseFirestore,
    private val auth: FirebaseAuth,
    private val dataStore: TaskDataStore
) : TaskRepository {

    /**
     * Observes the user's tasks in Firestore in real-time.
     *
     * This function sets up a snapshot listener on the user's "tasks" collection in Firestore.
     * It emits a new list of [Task] objects whenever the data changes. The listener is
     * automatically removed when the collecting flow is cancelled.
     *
     * @return A [Flow] that emits a list of [Task] objects.
     * @throws IllegalStateException if the user is not logged in.
     */
    override fun observeTasks(): Flow<List<Task>> = callbackFlow {
        // Check if the user is logged in
        val user = auth.currentUser

        // If the user is not logged in, emit an empty list and close the flow
        if (user == null) {
            trySend(emptyList())
            close()
            return@callbackFlow
        }

        // If the user is logged in, set up a snapshot listener on the user's "tasks" collection
        val listener = db.collection("users")
            .document(user.uid)
            .collection("tasks")
            .addSnapshotListener { snapshot, error ->
                if (error != null) {
                    close(error)
                    return@addSnapshotListener
                }
                // Convert the snapshot to a list of Task objects
                val tasks = snapshot?.documents?.map { doc ->
                    Task(
                        id = doc.id,
                        title = doc.getString("title") ?: "",
                        isCompleted = doc.getBoolean("isCompleted") ?: false
                    )
                }.orEmpty()
                // Emit the new list of tasks
                trySend(tasks)
            }
        // Close the flow when the collecting flow is cancelled
        awaitClose { listener.remove() }
    }

    /**
     * Starts a long-running synchronization process that observes tasks from Firebase
     * and saves them to the local data store.
     *
     * This function should be called with a CoroutineScope that will live for the duration
     * of the sync, typically from a ViewModel or a long-lived service.
     * Any previously running sync job on the provided scope is cancelled before
     * the new one is started.
     *
     * @param scope The CoroutineScope in which the synchronization will run.
     */
    override fun startSync(scope: CoroutineScope) {
        // Cancel any previous sync job if it's still running
        if (scope.isActive)
        scope.cancel()

        // Launch a new sync job in the provided scope
        scope.launch {
            observeTasks().collect { taskList ->
                dataStore.saveTasks(taskList)
            }
        }
    }

    /**
     * Retrieves a flow of tasks for the current user.
     *
     * This function observes the user's tasks collection in Firestore in real-time.
     * It returns a [Flow] that emits a new list of [Task] objects whenever the data changes.
     *
     * @return A [Flow] of the user's task list.
     */
    override fun tasks(): Flow<List<Task>> {
        Log.d("FirebaseTaskService", "tasks() called")
        return observeTasks()
    }

    /**
     * Adds a new task to the Firestore database for the currently authenticated user.
     *
     * This function first retrieves the current user's ID. It then generates a new document
     * reference in the user's "tasks" collection to get a unique ID for the new task.
     * The provided [task] object is updated with this new ID before being written to Firestore.
     *
     * @param task The [Task] object to be added. The `id` property of this object will be ignored
     *             and overwritten with a new ID generated by Firestore.
     * @return A [Result] wrapper indicating the outcome of the operation.
     *         - On success, it returns `Result.success(Unit)`.
     *         - On failure (e.g., user not logged in, network error), it returns `Result.failure(Exception)`.
     * @throws IllegalStateException if no user is currently logged in.
     */
    override suspend fun addTask(task: Task): Result<Unit> {
        return try {
            val userId = userId()

            val docRef = db.collection("users")
                .document(userId)
                .collection("tasks")
                .document()
            val taskWithId = task.copy(id = docRef.id)

            docRef.set(taskWithId).await()
            Log.d("FirebaseTaskService", "Task added: $task")
            Result.success(Unit)
        }
        catch (e: Exception) {
            Result.failure(e)
        }
    }

    override suspend fun editTask(taskId: String, newTitle: String?) {
        val userId = auth.currentUser?.uid
            ?: throw IllegalStateException("User not logged in")

        db.collection("users")
            .document(userId)
            .collection("tasks")
            .document(taskId)
            .update("title", newTitle)
            .await()
        Log.d("FirebaseTaskService", "Task edited: $taskId")
    }

    override suspend fun deleteTask(taskId: String) {
        val userId = auth.currentUser?.uid
            ?: throw IllegalStateException("User not logged in")

        db.collection("users")
            .document(userId)
            .collection("tasks")
            .document(taskId)
            .delete()
            .await()
        Log.d("FirebaseTaskService", "Task deleted: $taskId")
    }

    override suspend fun toggleTaskComplete(taskId: String, isCompleted: Boolean) {
        val userId = auth.currentUser?.uid
            ?: throw IllegalStateException("User not logged in")

        db.collection("users")
            .document(userId)
            .collection("tasks")
            .document(taskId)
            .update("isCompleted", isCompleted)
            .await()
        Log.d("FirebaseTaskService", "Task toggled: $taskId")
    }

    private fun userId(): String {
        return auth.currentUser?.uid ?: throw IllegalStateException("User not logged in")
    }
}
